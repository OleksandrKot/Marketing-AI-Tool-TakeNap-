"use client"

import { useCallback, useEffect, useState } from "react"

type FavoriteItem = {
  creativeId: string
  createdAt: string
  note?: string
}

type Collection = {
  id: string
  name: string
  itemIds: string[]
  owner?: string
  description?: string
  createdAt: string
  updatedAt?: string
}

type FavoritesStore = {
  version: number
  favorites: FavoriteItem[]
  collections: Collection[]
}

const STORAGE_KEY = "tn_favorites_v1"

function defaultStore(): FavoritesStore {
  return { version: 1, favorites: [], collections: [] }
}

function loadFromStorage(): FavoritesStore {
  if (typeof window === "undefined") return defaultStore()
  try {
    const raw = localStorage.getItem(STORAGE_KEY)
    if (!raw) return defaultStore()
    return JSON.parse(raw) as FavoritesStore
  } catch (e) {
    console.error("Failed to load favorites from storage", e)
    return defaultStore()
  }
}

function saveToStorage(state: FavoritesStore) {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state))
    // notify other hook instances in the same tab
    try {
      window.dispatchEvent(new CustomEvent("tn_favorites_updated"))
    } catch (e) {
      // ignore if dispatch fails in some environments
    }
  } catch (e) {
    console.error("Failed to save favorites to storage", e)
  }
}

export function useFavorites() {
  const [store, setStore] = useState<FavoritesStore>(() => loadFromStorage())

  useEffect(() => {
    function onStorage(e: StorageEvent) {
      if (e.key === STORAGE_KEY) setStore(loadFromStorage())
    }
    window.addEventListener("storage", onStorage)
    // listen for same-tab updates (storage events don't fire in the same tab)
    function onLocalUpdate() {
      setStore(loadFromStorage())
    }
    window.addEventListener("tn_favorites_updated", onLocalUpdate)
    return () => {
      window.removeEventListener("storage", onStorage)
      window.removeEventListener("tn_favorites_updated", onLocalUpdate)
    }
  }, [])

  useEffect(() => {
    saveToStorage(store)
  }, [store])

  const isFavorite = useCallback(
    (creativeId: string) => store.favorites.some((f) => f.creativeId === creativeId),
    [store.favorites],
  )

  const addFavorite = useCallback((creativeId: string, note?: string) => {
    setStore((prev) => {
      if (prev.favorites.some((f) => f.creativeId === creativeId)) return prev
      const fav: FavoriteItem = { creativeId, createdAt: new Date().toISOString(), note }
      const next = { ...prev, favorites: [...prev.favorites, fav] }
      saveToStorage(next)
      return next
    })
  }, [])

  const removeFavorite = useCallback((creativeId: string) => {
    setStore((prev) => {
      const next = { ...prev, favorites: prev.favorites.filter((f) => f.creativeId !== creativeId) }
      saveToStorage(next)
      return next
    })
  }, [])

  const toggleFavorite = useCallback(
    (creativeId: string) => {
      if (isFavorite(creativeId)) removeFavorite(creativeId)
      else addFavorite(creativeId)
    },
    [isFavorite, addFavorite, removeFavorite],
  )

  // Collections (basic)
  const createCollection = useCallback((name: string) => {
    const id = typeof crypto !== "undefined" && (crypto as any).randomUUID ? (crypto as any).randomUUID() : `${Date.now()}-${Math.random()}`
    setStore((prev) => {
      const col: Collection = { id, name, itemIds: [], createdAt: new Date().toISOString() }
      const next = { ...prev, collections: [...prev.collections, col] }
      saveToStorage(next)
      return next
    })
  }, [])

  const createCollectionWithOwner = useCallback((name: string, owner?: string, description?: string) => {
    const id = typeof crypto !== "undefined" && (crypto as any).randomUUID ? (crypto as any).randomUUID() : `${Date.now()}-${Math.random()}`
    setStore((prev) => {
      const col: Collection = { id, name, itemIds: [], owner, description, createdAt: new Date().toISOString() }
      const next = { ...prev, collections: [...prev.collections, col] }
      saveToStorage(next)
      return next
    })
  }, [])

  const deleteCollection = useCallback((collectionId: string) => {
    setStore((prev) => {
      const next = { ...prev, collections: prev.collections.filter((c) => c.id !== collectionId) }
      saveToStorage(next)
      return next
    })
  }, [])

  const addToCollection = useCallback((collectionId: string, creativeId: string) => {
    setStore((prev) => {
      const next = {
        ...prev,
        collections: prev.collections.map((c) =>
          c.id === collectionId ? { ...c, itemIds: Array.from(new Set([...c.itemIds, creativeId])), updatedAt: new Date().toISOString() } : c,
        ),
      }
      saveToStorage(next)
      return next
    })
  }, [])

  const updateCollection = useCallback((collectionId: string, updates: { name?: string; owner?: string; description?: string }) => {
    setStore((prev) => {
      const next = {
        ...prev,
        collections: prev.collections.map((c) => (c.id === collectionId ? { ...c, ...updates, updatedAt: new Date().toISOString() } : c)),
      }
      saveToStorage(next)
      return next
    })
  }, [])

  // allow setting a note for a favorite item (global per creative id)
  const setItemNote = useCallback((creativeId: string, note?: string) => {
    setStore((prev) => {
      const next = {
        ...prev,
        favorites: prev.favorites.map((f) => (f.creativeId === creativeId ? { ...f, note } : f)),
      }
      saveToStorage(next)
      return next
    })
  }, [])

  const removeFromCollection = useCallback((collectionId: string, creativeId: string) => {
    setStore((prev) => {
      const next = {
        ...prev,
        collections: prev.collections.map((c) => (c.id === collectionId ? { ...c, itemIds: c.itemIds.filter((i) => i !== creativeId), updatedAt: new Date().toISOString() } : c)),
      }
      saveToStorage(next)
      return next
    })
  }, [])

  const exportJSON = useCallback(() => JSON.stringify(store, null, 2), [store])

  const importJSON = useCallback((json: string) => {
    try {
      const parsed = JSON.parse(json) as FavoritesStore
      if (!parsed || !Array.isArray(parsed.favorites) || !Array.isArray(parsed.collections)) throw new Error("Invalid format")
      const next = { ...parsed, version: parsed.version || 1 }
      setStore(next)
      saveToStorage(next)
      return true
    } catch (e) {
      console.error("Failed to import favorites", e)
      return false
    }
  }, [])

  return {
    favorites: store.favorites,
    collections: store.collections,
    isFavorite,
    addFavorite,
    removeFavorite,
    toggleFavorite,
    createCollection,
    createCollectionWithOwner,
    deleteCollection,
    addToCollection,
    updateCollection,
    setItemNote,
    removeFromCollection,
    exportJSON,
    importJSON,
  }
}

export type { FavoriteItem, Collection }
